{
        "scope": "source.oracle meta.block.plsql meta.section.executable - meta.section.declare - meta.block.declaration",
        "completions":
        [
        	{ "trigger": "begin", "contents": "begin" },
        	{ "trigger": "begin\tanonymous block", "contents": "begin\n\t${0:null} ;\nexception\n\twhen others then\n\t\trollback ;\n\t\traise ;\nend ;" },
                { "trigger": "between", "contents": "between ${1:low}\n    and ${2:high}" },
                { "trigger": "binary_float_nan", "contents": "binary_float_nan" },
                { "trigger": "binary_float_infinity", "contents": "binary_float_infinity" },
                { "trigger": "binary_float_max_normal", "contents": "binary_float_max_normal" },
                { "trigger": "binary_float_min_normal", "contents": "binary_float_min_normal" },
                { "trigger": "binary_float_max_subnormal", "contents": "binary_float_max_subnormal" },
                { "trigger": "binary_float_min_subnormal", "contents": "binary_float_min_subnormal" },
                { "trigger": "binary_double_nan", "contents": "binary_double_nan" },
                { "trigger": "binary_double_infinity", "contents": "binary_double_infinity" },
                { "trigger": "binary_double_max_normal", "contents": "binary_double_max_normal" },
                { "trigger": "binary_double_min_normal", "contents": "binary_double_min_normal" },
                { "trigger": "binary_double_max_subnormal", "contents": "binary_double_max_subnormal" },
                { "trigger": "binary_double_min_subnormal", "contents": "binary_double_min_subnormal" },
                { "trigger": "case\tsimple case", "contents": "case ${1:selector}\n\twhen ${2:value1} then\n\t\tnull ;\n\twhen ${3:value2} then\n\t\tnull ;\n\telse\n\t\tnull ;\nend case ;" },
                { "trigger": "case\tsearched case", "contents": "case\n\twhen ${1:1 = 2} then\n\t\tnull ;\n\twhen ${2:2 = 1} then\n\t\tnull ;\n\telse\n\t\tnull ;\nend case ;" },
                { "trigger": "continue", "contents": "continue" },
                { "trigger": "continue when", "contents": "continue when ${1:1 = 1} ;" },
                { "trigger": "count", "contents": "count" },                
                { "trigger": "dbms_output", "contents": "dbms_output.put_line( '$0' ) ;" },
        	{ "trigger": "declare\tanonymous block", "contents": "declare\n\t$0\nbegin\n\tnull ;\nexception\n\twhen others then\n\t\trollback ;\n\t\traise ;\nend ;" },
                { "trigger": "delete", "contents": "delete" },
                { "trigger": "delete\telement", "contents": "delete( $0 )" },
                { "trigger": "exists", "contents": "exists( $0 )" },                
                { "trigger": "exit", "contents": "exit" },                
                { "trigger": "exit when", "contents": "exit when ${1:1 = 1} ;" },
                { "trigger": "extend\tby 1", "contents": "extend" },
                { "trigger": "extend\tby n", "contents": "extend( $0 )" },
                { "trigger": "extend\tby n copies of i", "contents": "extend( ${1:n}, ${2:i} )" },
                { "trigger": "first", "contents": "first" },                
                { "trigger": "fnd_file\tlog", "contents": "fnd_file.put_line( fnd_file.log, '$0' ) ;" },
                { "trigger": "fnd_file\toutput", "contents": "fnd_file.put_line( fnd_file.output, '$0' ) ;" },
                { "trigger": "for loop\tbasic", "contents": "for ${1:index} in reverse ${2:lower_bound}..${3:upper_bound} loop\n\tnull ;\nend loop ;" },
                { "trigger": "for loop\tnested table", "contents": "for ${1:index} in reverse ${2:table_name}.first..${2:table_name}.last loop\n\tnull ;\nend loop ;" },
                { "trigger": "for loop\treverse", "contents": "for ${1:index} in ${2:lower_bound}..${3:upper_bound} loop\n\tnull ;\nend loop ;" },
                { "trigger": "goto", "contents": "goto ${1:label} ;" },
        	{ "trigger": "if\tif..then", "contents": "if ${0:1 = 2} then\n\tnull ;\nend if;" },
        	{ "trigger": "if\tif..then..else", "contents": "if ${0:1 = 2} then\n\tnull ;\nelse\n\tnull ;\nend if;" },
        	{ "trigger": "if\tif..then..elsif", "contents": "if ${1:1 = 2} then\n\tnull ;\nelsif ${2:2 = 1} then\n\tnull ;\nelse\n\tnull ;\nend if;" },
                { "trigger": "last", "contents": "last" },                
                { "trigger": "like", "contents": "like" },
                { "trigger": "limit", "contents": "limit" },                
                { "trigger": "member", "contents": "member of" },
                { "trigger": "loop\tbasic", "contents": "loop\n\tnull ;\n\texit when 1 = 1 ;\nend loop ;" },
                { "trigger": "multiset\texcept", "contents": "multiset except " },
                { "trigger": "multiset\texcept distinct", "contents": "multiset except distinct " },
                { "trigger": "multiset\tintersect", "contents": "multiset intersect " },
                { "trigger": "multiset\tintersect distinct", "contents": "multiset intersect distinct " },
                { "trigger": "multiset\tunion", "contents": "multiset union " },
                { "trigger": "multiset\tunion distinct", "contents": "multiset union distinct " },
                { "trigger": "next", "contents": "next( $0 )" },                
                { "trigger": "null\tstatement", "contents": "null ;" },
                { "trigger": "prior", "contents": "prior( $0 )" },                
        	{ "trigger": "select\tsimple select", "contents": "select ${1:column}\n  into ${2:var}\n  from ${3:table}\n where 1 = 2 ;" },
                { "trigger": "submultiset", "contents": "submultiset of " },
                { "trigger": "trim\last element", "contents": "trim" },
                { "trigger": "trim\last n elements", "contents": "trim( $0 )" },
                { "trigger": "while loop\tbasic", "contents": "while ${1:condition} loop\n\tnull ;\n\texit when 1 = 1 ; -- or change the condition\nend loop ;" },
                { "trigger": "while loop\tassoc. array", "contents": "-- Declare idx with the same type as array index\nidx := ${1:array_name}.first ;\nwhile idx is not null loop\n\tnull ;\n\tidx := ${1}.next( idx ) ; \nend loop ;" }
        ]
}        